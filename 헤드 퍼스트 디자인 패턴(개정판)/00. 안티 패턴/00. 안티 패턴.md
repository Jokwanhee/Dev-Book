# 안티 패턴
안티 패턴은 나쁜 패턴이라고 한다. 큰 문제들은 아니지만 사소한 문제 즉, 바람직하지 않은 코딩 스타일을 말할 수 있다.

### 주석
주석을 달기 전에 코드를 변경해서 가독성 높은 코드를 만들어라.
### 코드 중복
코드 중복 시 해결할 수 있는 몇 가지 방법이 존재한다.
- 함수로 모듈화
- 객체지향에서는 상속 사용하기
- 구체적인 타입보다는 상위 타입으로 범용적으로 사용할 수 있는 방법
### 긴 함수, 큰 클래스
응집성은 높고, 결합성은 낮아야 한다.
### 데이터 클래스
데이터 클래스는 아주 작은 클래스를 말한다. 클래스 내 getter와 setter 만 있는 경우를 생각해보자. 큰 클래스도 문제지만 작은 클래스가 여러 개 있는 것도 문제이다. 
### 데이터 덩어리
항상 같이 등장하는 데이터가 있으면 이들을 묶어 데이터 클래스를 만들어 사용하는 것이 효과적
### 긴 매개변수 목록
인자의 개수를 줄일 수 있으면 좋다.

여기서 중요한 포인트는 데이터 덩어리와 연관이 있다.

먹는 함수가 존재할 때, 먹는 시작 시간과 끝나는 시간의 파라미터가 존재한다고 가정하자.
```java
foo(Date start, Date end)
```
여기서 보내는 인자를 데이터 덩어리로 바꾸면 어떨까?
```java
public class DateRange {
    public int start;
    public int end;
    public void foo() {}
}
```
```java
foo(DateRange range)
```
더 효율적이다!

# Code Smell
안티패턴은 다른 말로 Code Smell(코드 냄새)라고도 한다.
### Divergent change
응집성과 관련된 안티 패턴이다. (함수와 클래스는 응집성이 높아야 한다는 것이다.)

### Shotgun surgery
클래스 관계 중 의존관계. 반대로 A를 의존하는 것이 10개이다? A를 바꿔야하면 10개를 모두 변경해야 한다. 특정 클래스가 너무 많은 클래스를 의존하는 것은 바람직하지 않다.
### Feature envy
메소드의 코드 내용과 메소드의 위치가 잘못된 경우이다. 해당 메소드가 다른 객체의 상태를 많이 사용한다고 가정해보자. 그렇다면 다른 메소드로 이동해야한다. 즉, A라는 클래스의 메소드는 자신의 객체의 상태를 가지고 사용해야 한다.
### Inappropriate intimacy
일방향이 아닌 쌍방향은 올바르지 않다. (보통 의존 관계는 일방향이다.)
### Message chains
일련의 메소드 호출이 일어나는 경우
```java
p.getTeam().getManager()
```
위 체이닝 기법을 기계적으로 줄이는 것보다 전체적인 설계를 봐야 한다.

하지만 모든 메시지 체인은 코드냄새라고 할 수 없다.
```java
Time endTime = new Time.Builder(6).minute(30).build();
```
### Primitive obsession
원시 타입과 문자열을 너무 많이 사용하는 경우이다.

예시로 전화번호가 있다고 가정하자. 이 전화번호를 어떻게 모델링할 것인가?

- 문자열이라면, ("010-1234-5678");   
- telephone 이라는 클래스를 정의할까?
    - 해당 클래스를 정의하고 전화의 상태와 행위 멤버를 가진다면 더 효율적일 것 같다.
    - 그러면 원시타입 하나를 클래스로 정의한다면? 비효율적이지 않나?
    ```java
    double distance = 5;
    ```
    ```java
    Distance distance = Distance.kilometer(5);
    ```
    해당 방법은 괜찮은 방법이다. Distance 클래스는 거리를 나타내는 클래스이다. 거리 단위를 메소드로 호출함으로써 명확하게 알아볼 수 있어 더 효율적이다.

### Speculative Generality
지금 필요 없지만 미래에 필요할 것 같아서 일반화하는 경우이다.

즉, 지금 당장 사용하지 않는 클래스를 미리 구현하는 것이다. (미리 설계를 할 수 있지만 구현하는 것은 낭비할 수 있고 코드가 복잡해질 수 있다.)

확장성있게 미래에 필요하다고 예측이 된다면 나중에 사용할 때 녹아들 수 있게 할 수 있기는 하다.

### Switch statements
객체지향에서는 다형성 활용 가능

특히 반복되는 동일 형태의 switch 문은 제거하는 것이 좋다. (코드 중복 측면에서)

### Refused request
상속할 때 필요 없는 메소드를 상속받아야 하는 경우 : LSP, ISP

### Temporary field 
항상 사용하는 변수가 아니라 특정 경우에만 사용하는 멤버 변수는 코드 냄새에 해당한다. (가독성이 떨어지고, 유지보수가 어려움)

객체 클래스를 정의하고 객체를 생성할 때, 보통 멤버 변수가 있다면 그 멤버 변수를 초기화해주어야 한다. 일부 멤버 변수는 초기화하지 않고 효율성 때문에 나중에 초기화 한다.

그러면 위에서 설명한 방법은 Temporary field 인가? 그것은 또 아니다.
